#! /usr/local/bin/python3

import io
import os
import sys
import json
import traceback

class Cgi:
    # environment constants
    QUERY_STRING = "QUERY_STRING"
    REQUEST_METHOD = "REQUEST_METHOD"
    REQUEST_METHOD_POST = "POST"
    CONTENT_LENGTH = "CONTENT_LENGTH"
    CONTENT_TYPE = "CONTENT_TYPE"

    # constants we use internally (bedrock)
    MIME_TYPE_JSON = "application/json"
    UTF8 = "utf-8"

    QUERY = "query"

    STATUS = "status"
    STATUS_OK = "ok"
    STATUS_ERROR = "error"

    @staticmethod
    def parseContentType (contentType):
        splitResult = contentType.split(";", 1)
        if (len (splitResult) == 2):
            mimeType, encoding = splitResult
            encSplitResult = encoding.split ("=", 1)
            if (len (encSplitResult) == 2):
                encoding = encSplitResult[1]
            return [mimeType.strip(), encoding.strip ()]
        return [contentType.strip(), Cgi.UTF8]

    def __init__(self, env = os.environ):
        # default response
        # we only respond to post events so that HTTPS can mask exchanges
        if (Cgi.REQUEST_METHOD in env) and (env[Cgi.REQUEST_METHOD] == Cgi.REQUEST_METHOD_POST):
            # and the type and length must be specified
            if (Cgi.CONTENT_LENGTH in env) and (int (env[Cgi.CONTENT_LENGTH]) > 0):
                if (Cgi.CONTENT_TYPE in env):
                    mimeType, encoding = Cgi.parseContentType (env[Cgi.CONTENT_TYPE])
                    if (mimeType == Cgi.MIME_TYPE_JSON):
                        # we require that the POST data is JSON
                        inputStream = io.TextIOWrapper(sys.stdin.buffer, encoding=encoding)
                        inputJson = inputStream.read(int (env[Cgi.CONTENT_LENGTH]))
                        self.response = { Cgi.QUERY: json.loads(inputJson) }
                        self.response[Cgi.STATUS] = Cgi.STATUS_OK
                    else:
                        self.error ("Unsupported Request (CONTENT_TYPE must be '" + Cgi.MIME_TYPE_JSON + "')")
                else:
                    self.error ("Unsupported Request (CONTENT_TYPE must be specified)")
            else:
                self.error ("Unsupported Request (CONTENT_LENGTH must be specified and greater than 0)")
        else:
            self.error ("Unsupported Request (REQUEST_METHOD must be POST)")

        self.headers = {
            Cgi.CONTENT_TYPE: Cgi.MIME_TYPE_JSON + "; charset=" + Cgi.UTF8
            , "X-Content-Type-Options": "nosniff"
            , "Access-Control-Allow-Origin": "*"
            , "Access-Control-Allow-Headers": "*"
            , "Access-Control-Allow-Methods": "GET,POST,OPTIONS"
        }

    def error (self, description):
        self.response = { Cgi.STATUS: Cgi.STATUS_ERROR, Cgi.STATUS_ERROR : description }

try:
    cgi = Cgi ()

    # print the headers...
    for header in cgi.headers:
        print ("{}: {}".format (header, cgi.headers[header]))
    print ()

    # print the response
    print (json.dumps(cgi.response))
except Exception as exception:
    print ("{}:{}".format (Cgi.CONTENT_TYPE, "text/plain"))
    print ()
    print(traceback.format_exc())
