#! /usr/local/bin/python3

import io
import os
import sys
import json

# because I disagree with the python languyage design
false = False
true = True

# constants we use globally
MIME_TYPE_JSON = "application/json"
CHARSET = "charset"
CHARSET_UTF8 = "utf-8"

class CgiResponse:
    # cgi response headers
    STATUS_OK = "200 OK"
    STATUS_BAD_REQUEST = "400 Bad Request"
    STATUS_INTERNAL_SERVER_ERROR = "500 Internal Server Error"
    STATUS_UNSUPPORTED_REQUEST_METHOD = "501 Unsupported Request"

    HEADER_STATUS = "STATUS"
    HEADER_CONTENT_TYPE = "CONTENT-TYPE"

    @staticmethod
    def respond (headerStatus, response):
        # print the headers...
        print ("{}: {}".format (CgiResponse.HEADER_STATUS, headerStatus))
        print ("{}: {}".format (CgiResponse.HEADER_CONTENT_TYPE, MIME_TYPE_JSON + "; charset=" + CHARSET_UTF8))
        print ("X-Content-Type-Options: nosniff")
        print ("Access-Control-Allow-Origin: *")
        print ("Access-Control-Allow-Headers: *")
        # TODO not sure about OPTIONS - this is mostly for cross-domain requests
        print ("Access-Control-Allow-Methods: POST,OPTIONS")
        print ()

        # print the response
        print (response)

        # exit stage left
        sys.exit(0)

class Bedrock:
    QUERY = "query"
    RESPONSE = "response"
    RESPONSE_TIME_NS = "response-time-ns"
    STATUS = "status"
    OK = "ok"
    ERROR = "error"

    @staticmethod
    def __respond (status, query, responseName, response):
        bedrockResponse = { Bedrock.STATUS: status }

        # add the query
        if (query != None):
            bedrockResponse[Bedrock.QUERY] = query

        # add the response time
        bedrockResponse[Bedrock.RESPONSE_TIME_NS] = 1

        # add the response if there is one
        if (response != None):
            bedrockResponse[responseName] = response

        # bundle it all up and send it out the door
        CgiResponse.respond (CgiResponse.STATUS_OK, json.dumps (bedrockResponse))

    @staticmethod
    def __ok (query, response):
        Bedrock.__respond (Bedrock.OK, query, Bedrock.RESPONSE, response)

    @staticmethod
    def handleRequest (query):
        Bedrock.__ok (query, { "blah": "blah"})
        print ("hello")

    @staticmethod
    def error (query, description):
        Bedrock.__respond (Bedrock.ERROR, query, Bedrock.ERROR, description)

    @staticmethod
    def errorOnException (query, exception):
        trace = [ "({}) {}".format (type(exception).__name__, str(exception)) ]
        tb = exception.__traceback__
        while tb is not None:
            trace.append("({}) {}, line {}".format (tb.tb_frame.f_code.co_name, tb.tb_frame.f_code.co_filename, tb.tb_lineno))
            tb = tb.tb_next
        Bedrock.error(query, trace)

class CgiRequest:
    # cgi request header environment variables and values
    METHOD = "REQUEST_METHOD"
    METHOD_POST = "POST"
    CONTENT_LENGTH = "CONTENT_LENGTH"
    CONTENT_TYPE = "CONTENT_TYPE"

    @staticmethod
    def __common (variable, default = None, env = os.environ):
        if (variable in env):
            return env[variable]
        return default

    @staticmethod
    def __isJson ():
        contentType = CgiRequest.__common(CgiRequest.CONTENT_TYPE)
        if (contentType != None):
            return contentType.split (";", 1)[0].strip () == MIME_TYPE_JSON
        return false

    @staticmethod
    def __charset ():
        contentType = CgiRequest.__common(CgiRequest.CONTENT_TYPE)
        if (contentType != None):
            splitResult = contentType.split(";", 1)
            if (len (splitResult) == 2):
                parameters = {}
                for parameter in splitResult[1].split (";"):
                    attribute, parameters[attribute] = parameter.split ("=")
                if (CHARSET in parameters):
                    # technically the attribute value could be a quoted string that we should parse...
                    return parameters[CHARSET].strip (" '\"\t\r\n")
        # assume UTF-8 if no charset is passed, not technically correct according to standards, but for
        # most characters we encounter here will be the same as ASCII or iso-8859-1 (Western Latin 1)
        return CHARSET_UTF8

    @staticmethod
    def getAsDictionary ():
        # we only respond to post events so that HTTPS can mask exchanges
        if (CgiRequest.__common(CgiRequest.METHOD) == CgiRequest.METHOD_POST):
            # the type must be JSON
            if CgiRequest.__isJson():
                # the length must be specified
                contentLength = int (CgiRequest.__common(CgiRequest.CONTENT_LENGTH, 0))
                if (contentLength > 0):
                    inputStream = io.TextIOWrapper(sys.stdin.buffer, encoding=CgiRequest.__charset ())
                    inputJson = inputStream.read(contentLength)
                    return json.loads(inputJson)
        # this is just a base error - if we couldn't get a workable request
        CgiResponse.respond (CgiResponse.STATUS_BAD_REQUEST, "Bad Request ({} must be {}, {} must be {}, and {} > 0)".format (CgiRequest.METHOD, CgiRequest.METHOD_POST, CgiRequest.CONTENT_TYPE, MIME_TYPE_JSON, CgiRequest.CONTENT_LENGTH))


query = CgiRequest.getAsDictionary()

try:
    # read the cgi
    Bedrock.handleRequest(query)

except Exception as exception:
    Bedrock.errorOnException(query, exception)
